{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentaci\u00f3n del Proyecto","text":"<p>Bienvenido \ud83d\udc4b Esta es una plantilla basada en MkDocs + Material for MkDocs para cursos y proyectos.</p>"},{"location":"#empezar-rapido-3-pasos","title":"Empezar r\u00e1pido (3 pasos)","text":"<ol> <li>Edita el nombre del sitio en <code>mkdocs.yml</code>:    ```yaml    site_name: Documentaci\u00f3n del Curso    theme:      name: material</li> </ol>"},{"location":"ROS2_topics/","title":"ROS2 Publisher\u2013Subscriber: Number Accumulator","text":"<p>Activity: Implement two ROS 2 nodes using Python. The first node publishes a constant number periodically. The second node subscribes to that number, accumulates it, and publishes the result.</p>"},{"location":"ROS2_topics/#system-overview","title":"System Overview","text":"<p>The system is composed of two ROS2 nodes connected through topics: - Number publisher: Publishes a constant integer value to the /number topic. - Number counter: Subscribes to /number, accumulates the received values, and publishes the accumulated result to /number_count. The data flow can be summarized as: <pre><code>(number_publisher) \u2192 /number \u2192 (number_counter) \u2192 /number_count\n</code></pre></p>"},{"location":"ROS2_topics/#important-concepts","title":"Important concepts","text":"<p>What is a ROS 2 node? A node is an independent process that performs computation. Nodes can: - Publish messages - Subscribe to messages - Maintain internal satate In this system, each node has a specific responsability.</p> <p>What is a topic? A topic is a named communication channel used to exchange messages between nodes asynchronously.</p>"},{"location":"ROS2_topics/#1-number-publisher-node","title":"1) Number Publisher Node","text":"<p>Objective The purpose of the number_publisher node is to periodically publish a fixed integer value to the /number topic.</p> <p>This node only acts as a data source. - Initializes a publisher on /number - Uses a timer to publish every 1 second - Always publishes the same value (2)</p> <p>Code <pre><code>import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.msg import Int64\n\n# Node that publishes a constant number periodically\nclass numPublisher(Node):\n    def __init__(self):\n        # Initialize the node with a unique name\n        super().__init__(\"number_publisher\")\n\n        # Create a publisher on the /number topic with Int64 messages\n        self.publisher_ = self.create_publisher(Int64, \"/number\", 10)\n\n        # Create a timer that calls the number() method every 1 second\n        self.create_timer(1.0, self.number)\n\n        # Constant value to be published\n        self.number = 2\n\n        # Log node startup\n        self.get_logger().info(\"Sending number\")\n\n    def number(self):\n        # Create a hole numerical value as message\n        msg = Int64()\n\n        # Assign the constant number to the message\n        msg.data = self.number\n\n        # Publish the message\n        self.publisher_.publish(msg)\n\n        # Log the published value\n        self.get_logger().info(f\"Published: {msg.data}\")\n\ndef main(args=None):\n    # Initialize the ROS 2 Python client library\n    rclpy.init(args=args)\n\n    # Create the publisher node\n    my_publisher_node = numPublisher()\n\n    # Keep the node running\n    rclpy.spin(my_publisher_node)\n\n    # Shutdown ROS 2\n    rclpy.shutdown()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre></p>"},{"location":"ROS2_topics/#2-number-counter-node","title":"2) Number Counter Node","text":"<p>Objective The number_counter node receives numbers from /number, accumulates them, and publishes the running total to /number_count. This node functions both as a subscriber to my Number Publisher Node and as a publisher.</p> <p>Node Behavior - Subscribes to /number - Starts a counter using the recived nombar and adding 2 with each iteration - Publishes the updated counter immediately after receiving a message</p> <p>Code <pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.msg import Int64\n\n# Node that subscribes to /number, accumulates the values,\n# and publishes the result on /number_count\nclass numCounter(Node):\n    def __init__(self):\n        # Initialize the node with a unique name\n        super().__init__(\"number_counter\")\n\n        # Internal counter variable\n        self.counter = 0\n\n        # Subscribe to the /number topic\n        self.subscriber = self.create_subscription(\n            Int64,\n            \"/number\",\n            self.callback_receive_info,\n            10\n        )\n\n        # Publisher for the accumulated value\n        self.publisher = self.create_publisher(\n            Int64,\n            \"/number_count\",\n            10\n        )\n\n    def callback_receive_info(self, msg: Int64):\n        # Add the received number to the counter\n        self.counter += msg.data\n\n        # Create a message with the updated counter value\n        out_msg = Int64()\n        out_msg.data = self.counter\n\n        # Publish the updated counter\n        self.publisher.publish(out_msg)\n\n        # Log received and accumulated values\n        self.get_logger().info(\n            f\"Received: {msg.data} | Counter: {self.counter}\"\n        )\n\ndef main(args=None):\n    # Initialize the ROS 2 Python client library\n    rclpy.init(args=args)\n\n    # Create the counter node\n    counter_node = numCounter()\n\n    # Keep the node running\n    rclpy.spin(counter_node)\n\n    # Shutdown ROS 2\n    rclpy.shutdown()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre></p>"},{"location":"ROS2_topics/#results","title":"Results","text":"<p>Number Publisher Node</p> <p></p> <p>Number Counter Node</p> <p></p> <p>Graph of the nodes realtion</p> <p></p>"},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"fk_kuka_ur/","title":"Forward Kinematics for Kuka and UR robots","text":"<p>Activity: Get the matrix and diagrams for the Kuka and UR robots</p>"},{"location":"fk_kuka_ur/#important-concepts","title":"Important concepts","text":"<p>What are forward Kinematics? It refers to the study of motion, without considering forces, of a robot to calculate its final position and orientation of its end-effector, which refers to its last joint where a tool may be attached.</p> <p>How to obtain the forward kinematics of a robot?</p>"},{"location":"fk_kuka_ur/#step-1-establish-the-z-axis-of-each-joint","title":"Step 1: Establish the Z axis of each joint.","text":"<p>This depends mainly on the type of joint, the most used are the prismatic joint and the revolute joint. Those are the ones used in the following cases, therefore I\u2019m only focusing on them.  </p> <ul> <li>For a Prismatic joint, the Z axis is oriented along the joint linear displacement. This means that the Z axis will follow along in the direction between the Link of the interested joint i-1 unto the next joint i.</li> <li>For a revolute joint, the Z axis is oriented along the angle of rotation. This means that the Z axis is the line in which the revolute joint turns about.</li> </ul> <p></p>"},{"location":"fk_kuka_ur/#step-2-establish-the-origins-of-each-joint","title":"Step 2: Establish the origins of each joint.","text":"<p>Take the following sistem as an example:</p> <p></p> <p>As shown in the previous example, the first step is to define the Z-axis of each joint, which is chosen according to the type of joint and the direction of its motion. The origin of frame i is placed at the intersection of the Z-axis of the previous joint (Z i-1) and the Z-axis of the current joint (Z i).  </p> <p>For the first joint, the origin can be placed arbitrarily, since there is no previous Z-axis to intersect with. However, it is recommended to place the origin at the base of the joint, as this simplifies the model and avoids the need to introduce additional measurements to account for offsets. If at any point the axes Z i-1 and Z i do not intersect, the origin may be placed anywhere along the Z-axis of the current joint, considering it as an infinite line.</p> <p></p>"},{"location":"fk_kuka_ur/#step-3-establish-the-x-axis-for-each-joint","title":"Step 3: Establish the X axis for each joint.","text":"<p>The X-axis is placed orthogonally to both Z i-1 and Z i. This means that the X-axis forms a 90-degree angle with each of these Z-axes.</p> <p></p>"},{"location":"fk_kuka_ur/#step-4-establish-the-y-axis-for-each-joint","title":"Step 4: Establish the Y axis for each joint.","text":"<p>To obtain the transformation matrix for each joint, the Y-axis is not explicitly used. However, it is still good practice to define it in order to complete the reference frame of each joint. The Y-axis is defined according to the right-hand rule, so once the X- and Z-axes are established, the Y-axis is automatically determined.</p> <p></p> <p></p>"},{"location":"fk_kuka_ur/#step-5-the-denavit-hartenberg-convention","title":"Step 5: The Denavit-Hartenberg Convention.","text":"<p>A commonly used convention to select frames of reference in robotics is the Denavit-Hartenberg Convention. In this convention each homogeneous transformation matrix can be represented as the product of four basic transformations.</p> T i = R z ( \u03b8 i ) t z ( d i ) t x ( a i ) R x ( \u03b1 i ) <p>Where:</p> <p></p> <p>If we expand the transformation matrix T:</p> T i = [ cos \u2061 \u03b8 i \u2212 sin \u2061 \u03b8 i 0 0 sin \u2061 \u03b8 i cos \u2061 \u03b8 i 0 0 0 0 1 0 0 0 0 1 ] [ 1 0 0 0 0 1 0 0 0 0 1 d i 0 0 0 1 ] [ 1 0 0 a i 0 1 0 0 0 0 1 0 0 0 0 1 ] [ 1 0 0 0 0 cos \u2061 \u03b1 i \u2212 sin \u2061 \u03b1 i 0 0 sin \u2061 \u03b1 i cos \u2061 \u03b1 i 0 0 0 0 1 ] <p>Which simplifies to:</p> T i = [ cos \u2061 \u03b8 i \u2212 sin \u2061 \u03b8 i cos \u2061 \u03b1 i sin \u2061 \u03b8 i sin \u2061 \u03b1 i a i cos \u2061 \u03b8 i sin \u2061 \u03b8 i cos \u2061 \u03b8 i cos \u2061 \u03b1 i \u2212 cos \u2061 \u03b8 i sin \u2061 \u03b1 i a i sin \u2061 \u03b8 i 0 sin \u2061 \u03b1 i cos \u2061 \u03b1 i d i 0 0 0 1 ] <p>Whit this information we can creat a list with all of the D-H parameters and replace those values in the matrix for each joint.</p> <p></p>"},{"location":"fk_kuka_ur/#step-6-multiply-all-the-transformation-matrices","title":"Step 6: Multiply all the transformation matrices","text":"<p>Obtain the overall transformation of the robot, from the base to its end factor, by multiplying the individual transformation matirces: </p> n 0 T = 1 0 T \u22c5 2 1 T \u22c5 \u2026 \u22c5 n n \u2212 1 T <p></p>"},{"location":"forward_kinematics/","title":"Forward Kinematics","text":"<p>Activity: Get the matrix and DH placement of the frames, for the following robots</p>"},{"location":"forward_kinematics/#important-concepts","title":"Important concepts","text":"<p>What are forward Kinematics? It refers to the study of motion, without considering forces, of a robot to calculate its final position and orientation of its end-effector, which refers to its last joint where a tool may be attached.</p> <p>How to obtain the forward kinematics of a robot?</p>"},{"location":"forward_kinematics/#step-1-establish-the-z-axis-of-each-joint","title":"Step 1: Establish the Z axis of each joint.","text":"<p>This depends mainly on the type of joint, the most used are the prismatic joint and the revolute joint. Those are the ones used in the following cases, therefore I\u2019m only focusing on them.  </p> <ul> <li>For a Prismatic joint, the Z axis is oriented along the joint linear displacement. This means that the Z axis will follow along in the direction between the Link of the interested joint i-1 unto the next joint i.</li> <li>For a revolute joint, the Z axis is oriented along the angle of rotation. This means that the Z axis is the line in which the revolute joint turns about.</li> </ul> <p></p>"},{"location":"forward_kinematics/#step-2-establish-the-origins-of-each-joint","title":"Step 2: Establish the origins of each joint.","text":"<p>Take the following sistem as an example:</p> <p></p> <p>As shown in the previous example, the first step is to define the Z-axis of each joint, which is chosen according to the type of joint and the direction of its motion. The origin of frame i is placed at the intersection of the Z-axis of the previous joint (Z i-1) and the Z-axis of the current joint (Z i).  </p> <p>For the first joint, the origin can be placed arbitrarily, since there is no previous Z-axis to intersect with. However, it is recommended to place the origin at the base of the joint, as this simplifies the model and avoids the need to introduce additional measurements to account for offsets. If at any point the axes Z i-1 and Z i do not intersect, the origin may be placed anywhere along the Z-axis of the current joint, considering it as an infinite line.</p> <p></p>"},{"location":"forward_kinematics/#step-3-establish-the-x-axis-for-each-joint","title":"Step 3: Establish the X axis for each joint.","text":"<p>The X-axis is placed orthogonally to both Z i-1 and Z i. This means that the X-axis forms a 90-degree angle with each of these Z-axes.</p> <p></p>"},{"location":"forward_kinematics/#step-4-establish-the-y-axis-for-each-joint","title":"Step 4: Establish the Y axis for each joint.","text":"<p>To obtain the transformation matrix for each joint, the Y-axis is not explicitly used. However, it is still good practice to define it in order to complete the reference frame of each joint. The Y-axis is defined according to the right-hand rule, so once the X- and Z-axes are established, the Y-axis is automatically determined.</p> <p></p> <p></p>"},{"location":"forward_kinematics/#step-5-the-denavit-hartenberg-convention","title":"Step 5: The Denavit-Hartenberg Convention.","text":"<p>A commonly used convention to select frames of reference in robotics is the Denavit-Hartenberg Convention. In this convention each homogeneous transformation matrix can be represented as the product of four basic transformations.</p> T i = R z ( \u03b8 i ) t z ( d i ) t x ( a i ) R x ( \u03b1 i ) <p>Where:</p> <p></p> <p>If we expand the transformation matrix T:</p> T i = [ cos \u2061 \u03b8 i \u2212 sin \u2061 \u03b8 i 0 0 sin \u2061 \u03b8 i cos \u2061 \u03b8 i 0 0 0 0 1 0 0 0 0 1 ] [ 1 0 0 0 0 1 0 0 0 0 1 d i 0 0 0 1 ] [ 1 0 0 a i 0 1 0 0 0 0 1 0 0 0 0 1 ] [ 1 0 0 0 0 cos \u2061 \u03b1 i \u2212 sin \u2061 \u03b1 i 0 0 sin \u2061 \u03b1 i cos \u2061 \u03b1 i 0 0 0 0 1 ] <p>Which simplifies to:</p> T i = [ cos \u2061 \u03b8 i \u2212 sin \u2061 \u03b8 i cos \u2061 \u03b1 i sin \u2061 \u03b8 i sin \u2061 \u03b1 i a i cos \u2061 \u03b8 i sin \u2061 \u03b8 i cos \u2061 \u03b8 i cos \u2061 \u03b1 i \u2212 cos \u2061 \u03b8 i sin \u2061 \u03b1 i a i sin \u2061 \u03b8 i 0 sin \u2061 \u03b1 i cos \u2061 \u03b1 i d i 0 0 0 1 ] <p>Whit this information we can creat a list with all of the D-H parameters and replace those values in the matrix for each joint.</p> <p></p>"},{"location":"forward_kinematics/#step-6-multiply-all-the-transformation-matrices","title":"Step 6: Multiply all the transformation matrices","text":"<p>Obtain the overall transformation of the robot, from the base to its end factor, by multiplying the individual transformation matirces: </p> n 0 T = 1 0 T \u22c5 2 1 T \u22c5 \u2026 \u22c5 n n \u2212 1 T <p></p>"},{"location":"forward_kinematics/#exercise-1","title":"Exercise 1","text":"<p>To do te analysis of the robot, refer to the steps 1 to 4 of the Important Concepts menu.</p> <p></p> <p>Firts, the z-axis of every joint are established by following the movement of each joint of the robot as seen in the Step 1. Then the origins are established using the intersections of the z-axis of each joint. After that the x-axis is placed orthogonally to z i-1 and z i. Finally the y-axis of each joint is established by following the right hand rule.</p> <p></p> <p>Then refer to the step 5, the analysis of movement for each joint using the D-H method to facilitate obtaining the transformation matrix.</p> <p></p> <p>Finally, refer to step 6 to fill the satandar matrix with the contents obtained in the table, thus formulating the matrix for each joint.</p>"},{"location":"forward_kinematics/#exercise-2","title":"Exercise 2","text":"<p>To do te analysis of the robot, refer to the steps 1 to 4 of the Important Concepts menu.</p> <p></p> <p>Firts, the z-axis of every joint are established by following the movement of each joint of the robot as seen in the Step 1. Then the origins are established using the intersections of the z-axis of each joint. After that the x-axis is placed orthogonally to z i-1 and z i. Finally the y-axis of each joint is established by following the right hand rule.</p> <p></p> <p>Then refer to the step 5, the analysis of movement for each joint using the D-H method to facilitate obtaining the transformation matrix.</p> <p></p> <p>Finally, refer to step 6 to fill the satandar matrix with the contents obtained in the table, thus formulating the matrix for each joint.</p>"},{"location":"forward_kinematics/#exercise-2_1","title":"Exercise 2","text":"<p>To do te analysis of the robot, refer to the steps 1 to 4 of the Important Concepts menu.</p> <p></p> <p>Firts, the z-axis of every joint are established by following the movement of each joint of the robot as seen in the Step 1. Then the origins are established using the intersections of the z-axis of each joint. After that the x-axis is placed orthogonally to z i-1 and z i. Finally the y-axis of each joint is established by following the right hand rule.</p> <p></p> <p>Then refer to the step 5, the analysis of movement for each joint using the D-H method to facilitate obtaining the transformation matrix.</p> <p></p> <p>Finally, refer to step 6 to fill the satandar matrix with the contents obtained in the table, thus formulating the matrix for each joint.</p>"},{"location":"forward_kinematics/#exercise-3","title":"Exercise 3","text":"<p>To do te analysis of the robot, refer to the steps 1 to 4 of the Important Concepts menu.</p> <p></p> <p>Firts, the z-axis of every joint are established by following the movement of each joint of the robot as seen in the Step 1. Then the origins are established using the intersections of the z-axis of each joint. After that the x-axis is placed orthogonally to z i-1 and z i. Finally the y-axis of each joint is established by following the right hand rule.</p> <p></p> <p>Then refer to the step 5, the analysis of movement for each joint using the D-H method to facilitate obtaining the transformation matrix.</p> <p></p> <p></p> <p>Finally, refer to step 6 to fill the satandar matrix with the contents obtained in the table, thus formulating the matrix for each joint.</p>"},{"location":"forward_kinematics/#exercise-3_1","title":"Exercise 3","text":"<p>To do te analysis of the robot, refer to the steps 1 to 4 of the Important Concepts menu.</p> <p></p> <p>Firts, the z-axis of every joint are established by following the movement of each joint of the robot as seen in the Step 1. Then the origins are established using the intersections of the z-axis of each joint. After that the x-axis is placed orthogonally to z i-1 and z i. Finally the y-axis of each joint is established by following the right hand rule.</p> <p></p> <p>Then refer to the step 5, the analysis of movement for each joint using the D-H method to facilitate obtaining the transformation matrix.</p> <p></p> <p></p> <p>Finally, refer to step 6 to fill the satandar matrix with the contents obtained in the table, thus formulating the matrix for each joint.</p>"},{"location":"forward_kinematics/#exercise-4","title":"Exercise 4","text":"<p>To do te analysis of the robot, refer to the steps 1 to 4 of the Important Concepts menu.</p> <p></p> <p>Firts, the z-axis of every joint are established by following the movement of each joint of the robot as seen in the Step 1. Then the origins are established using the intersections of the z-axis of each joint. After that the x-axis is placed orthogonally to z i-1 and z i. Finally the y-axis of each joint is established by following the right hand rule.</p> <p></p> <p>Then refer to the step 5, the analysis of movement for each joint using the D-H method to facilitate obtaining the transformation matrix.</p> <p></p> <p></p> <p></p> <p>Finally, refer to step 6 to fill the satandar matrix with the contents obtained in the table, thus formulating the matrix for each joint.</p>"},{"location":"forward_kinematics/#exercise-5","title":"Exercise 5","text":"<p>To do te analysis of the robot, refer to the steps 1 to 4 of the Important Concepts menu.</p> <p></p> <p>Firts, the z-axis of every joint are established by following the movement of each joint of the robot as seen in the Step 1. Then the origins are established using the intersections of the z-axis of each joint. After that the x-axis is placed orthogonally to z i-1 and z i. Finally the y-axis of each joint is established by following the right hand rule.</p> <p></p> <p>Then refer to the step 5, the analysis of movement for each joint using the D-H method to facilitate obtaining the transformation matrix.</p> <p></p> <p></p> <p>Finally, refer to step 6 to fill the satandar matrix with the contents obtained in the table, thus formulating the matrix for each joint.</p>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"services/","title":"Ros2 Service Server","text":"<p>Activity: Using the number_counter node from the \"ROS2 Publisher-Subscriber: Number Accumulator\" assignment, creat a service that uses boolean values to restar the node counter.</p> <p>Visit the ROS2 Publisher-Subscriber: Number Accumulator assignment to check the codes in wich I worked upon in this assignment</p>"},{"location":"services/#1implementig-and-undestanding-the-service-interface","title":"1)Implementig and undestanding the service interface","text":"<p>The objective is to implement a service server that upon beeing called, will check the (bool data) from the request, then by (bool suceess) it will indicate a succesfull run of trigerred service, finally an informational message will be sent by (string message) to print any inidcation, error, or information that's considered important. All this using the arlready-installed interface: <pre><code>example_interfaces/srv/SetBool\n</code></pre></p> <p>Inspect the interface, in the Ubuntu terminal, on your work space, use the following comand:  </p> <pre><code>ros2 interface show example_interfaces/srv/SetBool\n</code></pre> <p>Expected output:</p> <pre><code>bool data # e.g. for hardware enabling / disabling\n---\nbool success   # indicate successful run of triggered service\nstring message # informational, e.g. for error messages\n</code></pre> <p>The (---) separates: - Request (client to server): bool request - Response (server to client): bool success, string message  </p>"},{"location":"services/#2-server-implementation","title":"2) Server implementation","text":""},{"location":"services/#imports","title":"Imports","text":"<p><pre><code>#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.msg import Int64 \nfrom example_interfaces.srv import SetBool\n</code></pre> What does it do? - Service live under ...srv - SetBool contains both:     - bool request (data)     - bool response (successm, string message)   </p> <p>Important Add example_interface to the package.xml file like so:  </p> <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;?xml-model href=\"http://download.ros.org/schema/package_format3.xsd\" schematypens=\"http://www.w3.org/2001/XMLSchema\"?&gt;\n&lt;package format=\"3\"&gt;\n  &lt;name&gt;my_robots_pacage&lt;/name&gt;\n  &lt;version&gt;0.0.0&lt;/version&gt;\n  &lt;description&gt;TODO: Package description&lt;/description&gt;\n  &lt;maintainer email=\"corne@todo.todo\"&gt;corne&lt;/maintainer&gt;\n  &lt;license&gt;TODO: License declaration&lt;/license&gt;\n\n  &lt;depend&gt;rclpy&lt;/depend&gt;\n  &lt;depend&gt;example_interfaces&lt;/depend&gt;\n\n  &lt;test_depend&gt;ament_copyright&lt;/test_depend&gt;\n  &lt;test_depend&gt;ament_flake8&lt;/test_depend&gt;\n  &lt;test_depend&gt;ament_pep257&lt;/test_depend&gt;\n  &lt;test_depend&gt;python3-pytest&lt;/test_depend&gt;\n\n  &lt;export&gt;\n    &lt;build_type&gt;ament_python&lt;/build_type&gt;\n  &lt;/export&gt;\n&lt;/package&gt;\n</code></pre>"},{"location":"services/#define-the-node-class-and-constructor","title":"Define the node class and constructor","text":"<p><pre><code>class numCounter(Node):\n    def __init__(self):\n        #Initialize node with the name \"number_counter\"\n        super().__init__(\"number_counter\")\n</code></pre> What does it do? - Creates a node class called: numCounter - Sets the node name to: number_counter </p>"},{"location":"services/#create-the-service-server-starts-the-counter-on-0","title":"Create the service server, starts the counter on 0","text":"<p><pre><code>        self.server_ = self.create_service(SetBool, \"/reset_counter\",self.read_bool_callback) # Creats a service server type SetBool. It needs: (Service type, service name, callback function)\n        self.counter = 0 # Start the counter on 0\n</code></pre> What does it do? - Creates the server with it's type: SetBool, service name: /reset_counter, callback function: self.read_bool_callback - Starts the counter on 0  </p>"},{"location":"services/#create-the-service-callback-function","title":"Create the service callback function","text":"<p><pre><code># Service callback for /reset_counter\n    def read_bool_callback(self, request, response):\n        # Boolean condition if request.data is true, reset the counter to 0.\n        if request.data:\n            # reset counter\n            self.counter = 0;\n            #Indicates succesful reset\n            response.success = True\n            response.message = \"Counter reset to 0\"\n            # Log reset event\n            self.get_logger().info(\"Counter restarted to 0\")\n        else:\n            # No reset performed\n            response.success = False\n            response.message = \"Counter not reset\"\n        return response\n</code></pre> What does it do? - Starts the service callback for /reset_counter - Calls the boolean value: request.data; If true, resets the counter to 0 - Indicates succesful reset: response.success = True. response.message = \"Counter reset to 0\" - Log info for counter reset event: self.get_logger().info(\"Counter restarted to 0\") - In case the boolean value: request.data is false, nothing happens - Indicates the reset not performed: response.success = False, response.message = \"Counter not reset\" </p>"},{"location":"services/#3-full-code-the-number_counter-code-with-the-server-modifications","title":"3) Full code (the number_counter code with the server modifications)","text":"<pre><code>#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.msg import Int64 \nfrom example_interfaces.srv import SetBool\n\nclass numCounter(Node):\n    def __init__(self):\n        #Initialize node with the name \"number_counter\"\n        super().__init__(\"number_counter\")\n        self.server_ = self.create_service(SetBool, \"/reset_counter\",self.read_bool_callback) # Creats a service server type SetBool. It needs: (Service type, service name, callback function)\n        self.counter = 0 # Start the counter on 0\n        self.subscriber = self.create_subscription(Int64,\"/number\", self.callback_receive_info,10) # (Type, topic name, callback function, queue size)\n        self.publisher = self.create_publisher(Int64,\"/number_count\",10) # (Type, topic name, queue size)\n\n    #Subscriber callback. Triggers every time a message is received on /number. Adds the received value to the internal counter and publishes the updated total.\n    def callback_receive_info(self, msg: Int64): #its receiving a msg of type String\n        # Acumulate recived value\n        self.counter += msg.data\n        # Create message to publish\n        out_msg = Int64()\n        out_msg.data = self.counter\n        #Log received value and current counter state\n        self.get_logger().info(f\"Recived: {msg.data} | Counter: {self.counter}\") #print the data field\n        #Published updated counter value\n        self.publisher.publish(out_msg)\n\n    # Service callback for /reset_counter. If request.data is true, reset the counter to 0.\n    def read_bool_callback(self, request, response):\n        # Boolean condition\n        if request.data:\n            # reset counter\n            self.counter = 0;\n            #Indicates succesful reset\n            response.success = True\n            response.message = \"Counter reset to 0\"\n            # Log reset event\n            self.get_logger().info(\"Counter restarted to 0\")\n        else:\n            # No reset performed\n            response.success = False\n            response.message = \"Counter not reset\"\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args) # Initialize rclpy\n    counter_node = numCounter() # Create node instance\n    rclpy.spin(counter_node) # Keep the node alive and processing callbacks\n    rclpy.shutdown()      # Shutdown rclpy\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"services/#4-build-the-server","title":"4) Build the server","text":"<ul> <li>Add an entry point for the server script in your setup.py, in the console_scripts secction:  </li> </ul> <pre><code>from setuptools import find_packages, setup\n\npackage_name = 'my_robots_pacage'\n\nsetup(\n    name=package_name,\n    version='0.0.0',\n    packages=find_packages(exclude=['test']),\n    data_files=[\n        ('share/ament_index/resource_index/packages',\n            ['resource/' + package_name]),\n        ('share/' + package_name, ['package.xml']),\n    ],\n    install_requires=['setuptools'],\n    zip_safe=True,\n    maintainer='corne',\n    maintainer_email='corne@todo.todo',\n    description='TODO: Package description',\n    license='TODO: License declaration',\n    extras_require={\n        'test': [\n            'pytest',\n        ],\n    },\n    entry_points={\n        'console_scripts': [\n            'num_publisher = my_robots_pacage.number_publisher:main',\n            'num_counter = my_robots_pacage.number_counter:main', # here is my service server entry \n        ],\n    },\n)\n</code></pre> <ul> <li>In Ubuntu, on your work space, OUTSIDE of src, build your project using:  </li> </ul> <pre><code>colcon build\n</code></pre>"},{"location":"services/#5-test-your-server","title":"5) Test your server","text":"<p>First start the publisher_node that the number_counter node will subsribe to in the Ubuntu terminal:</p> <pre><code>ros2 run &lt;your_package_name&gt; &lt;your_publisher_node_name&gt;\n</code></pre> <p>It should look like this:</p> <p></p> <p>Next, start the number_counter node in another Ubuntu terminal: </p> <pre><code>ros2 run &lt;your_package_name&gt; &lt;your_number_counter_node_name&gt;\n</code></pre> <p>It should look like this: </p> <p></p> <p>Next, in another Ubuntu terminal, call the service server, with a \"true\" boolean value:</p> <pre><code>ros2 service call /&lt;name of your service server&gt; example_interfaces/srv/SetBool \"{data: true}\"\n</code></pre> <p>It should look like this: </p> <p></p> <p>And the reset on the number_counter should look like this:</p> <p></p> <p>Calling on the service server with a \"Fale\" boolean value:</p> <pre><code>ros2 service call /&lt;name of your service server&gt; example_interfaces/srv/SetBool \"{data: false}\"\n</code></pre> <p>Should look like this:</p> <p></p>"},{"location":"transform_nom/","title":"Transform Nomenclature","text":"<p>Activity: Write the correct nomenclature for the frame transform, in the following problems.</p>"},{"location":"transform_nom/#important-concepts","title":"Important concepts","text":"<p>-What is the right hand rule and how does it help in this tipe of problems? The right hand rule is used to define the orientaion of the Cartesian coordinate systems in three dimensions. In a right-handed coordinate system, the directions of the X, Y, and Z axes are related by the right hand: the index finger points along the X-axis, the middle finger points along the Y-axis,then the thumb, extended perpendicular to both, points in the direction of the Z-axis. The right-hand rule is also a convention used to determine the direction of rotation and to define whether a rotation is positive or negative. To apply it, point the thumb of your right hand in the direction of the positive axis of rotation. The direction in which your fingers curl indicates the positive direction of rotation around that axis.</p> <p></p>"},{"location":"transform_nom/#1-first-problem","title":"1) First problem","text":"<p>The first step to solve this problem is to get the matrixes of each rotation of the stablished vector, it is important to solve it following the chronological order in which the problem states the rotations happened, in this case, first the rotation about the Y axis and then the rotation about the X axis.</p> <p>-How can rotation be visualized? To better visualize rotational transformations, it is helpful to represent the vector within a Cartesian coordinate system. A rotation about a given axis leaves the component aligned with that axis unchanged, while the remaining components are transformed. For example, a rotation about the Y-axis affects only the X and Z components of the vector, as the rotation takes place in the plane perpendicular to the Y-axis. This behavior is reflected in the corresponding rotation matrix, where the Y component remains constant.</p> <p>In the images below, in the drawn cartesian planes, it can be observed the original position vectors, represented by X_1 and Y_1, as well as the positions of said vectors after the rotation, represented by X_2 and Y_2. Since the problem also has the angle of rotation in both cases, we can use cos and sin relations to find the new coordinates, resulting in the matrixes of each corresponding rotation.</p> <p></p> <p></p> <p>This problem describes a vector experiencing two rotations, so after obtaining the matrix for each rotation we need to multiply said matrixes to obtain the rotation matrix R that performs the rotations in the indicated order. It is important to remember that matrix multiplication is not commutative so the order in which they are multiplied matters. In the case of rotation matrixes, we order the multiplication from the latest matrix to the first one, as we can see in the following image:</p> <p></p> <p>In order to multiply two matrices, the number of columns of the first matrix must be equal to the number of rows of the second matrix. Each element of the resulting matrix is obtained by taking the dot product of a row from the first matrix with a column from the second matrix.</p> <p></p> <p>Finally we just need to simplify our result and we get the rotation matrix R whit all its axis components:</p>"},{"location":"transform_nom/#_1","title":"Transform Nomenclature","text":""},{"location":"transform_nom/#2-second-problem","title":"2) Second problem","text":"<p>In this problem it can be observed that the reference frame experiences two different kinds of movement, a rotation and then translation. Same as the last problem, the movement of the reference frame must be analyzed in order the problem to present them, in this case, first the rotation of the reference frame B with respect to the reference frame A, then the translation form B to A.</p> <p></p> <p>For the rotation of reference frame B the problem is asking to make said rotation with respect to reference frame A about X_A by 30\uf0b0. This means that we are going to use the right-hand rule in A in order to follow that movement when B is rotated. Like so:</p> <p></p> <p>Notice that since the problem asks to make the rotation with respect to reference frame A about X_A, in the perspective of reference frame B the rotation is negative as such, the rotation angle in the view point of reference frame B is -30 degrees. By making the visualization of the rotation in reference frame B, its matrix can be calculated:</p> <p></p> <p>The next step would be to calculate the translation of B from A but in this case the problem already establishes it, but since its a 3D space the point is represented as such:</p> <p></p> <p>Now the problem is asking the formulation of a homogeneous transform matrix. Which is the combination of both rotation and translation in a single transformation. This results in a 4x4 matrix containing the matrix of the rotation and the translation vector. For this particular problem it looks like this:</p>"},{"location":"transform_nom/#_2","title":"Transform Nomenclature","text":""},{"location":"transform_nom/#3third-problem","title":"3)Third problem","text":"<p>This problem is asking for the homogeneouus transformation matrix from reference frame A to reference frame B, as well as the transformation matrix from reference frame A to reference frame C. So in this case we have to different matrixes that are independent from one another so it each one recures an individual analysis of the movement that composes them.</p> <p>In my case I decided to star by studying the transformation matrix from reference frame A to reference frame B, keep in mind that it won\u2019t affect the result which one is solved first since they don\u2019t hold any relation to each other.</p> <p>For the movement from frame A to B it can be concluded by looking at image presented that the first movement of this transformation is a translation. As shown in the following image, the translation from frame A to B is simple as its only translation over the X axis, meaning that the vector would look like this (considering that we are solving a problem in a 3D space):</p> <p></p> <p>Now the translated frame must be rotated in a way that matches its destination as it\u2019s shown. It can be observed that the translated A frame Y_A and X_A axis are in the opposite direction in comparison to the Y_B and X_A axis. It can be concluded that the rotation is about the Z axes by an angle of 180 degrees:</p> <p></p> <p>Having the rotation visualized, the rotation matrix can be formulated:</p> <p></p> <p>Now all that is left is to obtain the homogeneous transformation matrix by combining both the vector translation and the matrix rotation as we did the last problem:</p> <p></p> <p>For the homogeneous transformation matrix from A to C we can assume that the first movement was also a translation, this translation is composed of coordinates. X and Z which results in a translator vector:</p> <p></p> <p>It now can be observed that to complete the transformation from A to C, we need rotations, and after analyzing the image it can be concluded that the rotations are as follows: one rotation along the Y axis, and another along the X axis. As a side tangent its important to bring up the fact that one the A frame is translated onto the C frame, none of the axis from the A frame are aligned with the C frame, which means that you can start the rotation alongside any axis, that would result in one or more axis from the A frame to coincide with the axis of the C frame, and get to the same point as anyone else that\u2019s doing the same exercise because physically, if the problem is solved correctly, the matrixes product will be equivalent to other products made by other people, and this doesn\u2019t have anything to do with any commutative properties (which matrixes don\u2019t have). It\u2019s more so because by using different axis as reference we create equivalent matrixes.  Basically, it doesn\u2019t matter which rotation anyone choose to start (which in this case there are only 4 possible combinations) as long as the rotations end with the frame A coinciding with the frame C the matrixes will be equivalent. In my case I started the rotation alongside the Y axis by 90 degrees:</p> <p></p> <p>Once we star to visualize and follow the rotation is very easy to understand by which axis it needs to be rotated, in the image above its logical that the next rotation is made along the X axis by -30 degrees.</p> <p></p> <p>Once we have both matrixes we need to multiply them to now the complete rotation of the AC frame.</p> <p></p> <p>After simplifying the matrix we get this:</p> <p></p> <p>All that is left is to obtain the homogeneous transformation matrix by combining both the vector translations with the frame rotation:</p> <p></p>"}]}